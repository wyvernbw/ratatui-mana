//! # Layout
//!
//! implements the layout algorithm.
use std::{
    ops::{Deref, Div},
    sync::Arc,
};

use derive_more as d;
use glam::{U16Vec2, u16vec2};
use hecs::{Bundle, CommandBuffer, Component, ComponentError, DynamicBundle, Entity, Query, World};
use ratatui::{
    buffer::Buffer,
    layout::{Direction, Rect},
    widgets::{Padding, Widget},
};

/// trait for rendering elements through a shared reference. this is automatically implemented
/// for anything that implements [`Widget`], [`Clone`] and [`Component`]
pub trait ElWidget: std::fmt::Debug + Component {
    /// render the element through the shared reference. clones internally
    fn render_element(&self, area: Rect, buf: &mut Buffer);
}

impl<W: 'static> ElWidget for W
where
    W: Widget + Clone + std::fmt::Debug + Component,
{
    fn render_element(&self, area: Rect, buf: &mut Buffer) {
        self.clone().render(area, buf);
    }
}

/// Context struct that drives the layout engine.
///
/// # Usage
///
/// - [`ElementCtx::deref`] derefs to the inner [`hecs::World`]
/// - [`ElementCtx::spawn_ui`] takes a builder generated by the [`ui`][crate::ui::ui] function and spawns it and all its children
/// - [`ElementCtx::calculate_layout`] takes the root element and calculates sizes and positions.
/// - [`ElementCtx::render`] renders the tree to the provided buffer.
///
/// # Example
///
/// ```
/// # use mana_tui_elemental::prelude::*;
/// # use ratatui::buffer::Buffer;
/// # use ratatui::layout::Rect;
///
/// let mut ctx = ElementCtx::new();
///
/// let root = ui(Text::raw("hello world"));
/// let root = ctx.spawn_ui(root);
///
/// # let mut buf = Buffer::empty(Rect::new(0, 0, 50, 24));
/// // `&mut Buffer` from ratatui
/// ctx.calculate_layout(root, buf.area).unwrap();
/// ctx.render(root, buf.area, &mut buf);
/// ```
///
/// see [`ui module`][crate::ui] for more details.
#[derive(Default, d::Deref, d::DerefMut)]
pub struct ElementCtx {
    #[deref]
    #[deref_mut]
    pub(crate) world: World,
}

impl ElementCtx {
    /// create an empty context.
    pub fn new() -> Self {
        Self::default()
    }
    fn calculate_fit_sizes(&self, element: Element) -> Result<(), ComponentError> {
        let mut query = self
            .world
            .query_one::<(&Width, &Height, &Padding, &Children, &Direction)>(element)?;
        let (width, height, padding, children, direction) = query.get().unwrap();
        let mut props_query = self.world.query_one::<&mut Props>(element)?;
        let props = props_query.get().unwrap();

        if let Size::Fixed(size) = **width {
            props.size.x = size;
        }
        if let Size::Fixed(size) = **height {
            props.size.y = size;
        }
        let max_size = props.size.saturating_sub(u16vec2(
            padding.right + padding.left,
            padding.bottom + padding.top,
        ));

        let mut space_used = AxisSizes::default();

        drop(props_query);

        children
            .iter()
            .try_for_each(|child| -> Result<(), ComponentError> {
                self.calculate_fit_sizes(child)?;
                Ok(())
            })?;

        for child in children {
            let mut child_props = self.world.get::<&mut Props>(child)?;
            if width.should_clamp() {
                child_props.size.x = child_props.size.x.clamp(0, max_size.x);
            }
            if height.should_clamp() {
                child_props.size.y = child_props.size.y.clamp(0, max_size.x);
            }
            space_used = space_used.increase(child_props.size, *direction);
        }

        let mut query = self.world.query_one::<(
            &mut Props,
            &Width,
            &Height,
            &Padding,
            &Children,
            &Direction,
            &Gap,
        )>(element)?;
        let (props, width, height, padding, children, direction, gap) = query.get().unwrap();

        space_used = space_used.pad(*padding, *direction);
        space_used.main_axis += children.len().saturating_sub(1) as u16 * **gap;
        let space_used = space_used.to_u16vec2(*direction);
        match **width {
            Size::Fit | Size::Grow => {
                props.size.x = space_used.x;
            }
            _ => {}
        }
        match **height {
            Size::Fit | Size::Grow => {
                props.size.y = space_used.y;
            }
            _ => {}
        }
        tracing::trace!(target: "mana-tui::fit", ?element, ?props.size);
        Ok(())
    }
    fn sum_space_used(&self, elements: &[Element]) -> U16Vec2 {
        elements
            .iter()
            .copied()
            .flat_map(|child| self.world.get::<&Props>(child))
            .map(|props| props.size)
            .sum::<U16Vec2>()
    }
    fn calculate_grow_sizes(
        &self,
        element: Element,
        is_root: bool,
        area: Rect,
    ) -> Result<(), ComponentError> {
        let mut query = self
            .world
            .query_one::<(&mut Props, &Padding, &Children, &Direction, &Gap)>(element)?;
        let (props, &padding, children, &direction, &gap) = query.get().unwrap();

        let children = children.clone();
        let inner_size = props.size.saturating_sub(u16vec2(
            padding.right + padding.left,
            padding.bottom + padding.top,
        ));

        drop(query);

        let space_used = self.sum_space_used(&children);
        let remaining_size = inner_size.saturating_sub(space_used);
        let mut remaining_size = axify(remaining_size, direction);
        remaining_size.main_axis = remaining_size
            .main_axis
            .saturating_sub(children.len().saturating_sub(1) as u16 * *gap);

        if is_root {
            let mut query = self
                .world
                .query_one::<(&mut Props, &Width, &Height)>(element)?;
            let (props, width, height) = query.get().unwrap();
            // if the root element is set to grow, we want it to take up the entire
            // screen.
            if width.is_grow() {
                props.size.x = area.width;
            }
            if height.is_grow() {
                props.size.y = area.height;
            }
        }

        // cross axis
        children
            .iter()
            .try_for_each(|child| -> Result<(), ComponentError> {
                let mut child_query = self
                    .world
                    .query_one::<(&mut Props, &Width, &Height)>(child)?;
                let (child_props, child_width, child_height) = child_query.get().unwrap();
                if !cross_size(direction, *child_width, *child_height).is_grow() {
                    return Ok(());
                }
                let mut size = AxisSizes::from_u16vec2(child_props.size, direction);
                size.cross_axis = axify(inner_size, direction).cross_axis;
                child_props.size = size.to_u16vec2(direction);
                Ok(())
            })?;

        // main axis
        #[derive(Query, Debug)]
        struct GrowQuery<'a> {
            props: &'a mut Props,
            width: &'a Width,
            height: &'a Height,
        }
        #[derive(d::Debug)]
        struct GrowEntry {
            is_grow: bool,
            #[debug("({}, {})", self.size.main_axis, self.size.cross_axis)]
            size: AxisSizes,
            entity: Element,
        }
        let mut buffer = children
            .iter()
            .flat_map(|child| self.query_one::<GrowQuery>(child).ok().zip(Some(child)))
            .map(|(mut grow_query, entity)| {
                let grow_query = grow_query.get().unwrap();
                let is_grow = main_size(direction, *grow_query.width, *grow_query.height).is_grow();
                let size = axify(grow_query.props.size, direction);
                GrowEntry {
                    is_grow,
                    size,
                    entity,
                }
            })
            .collect::<Vec<_>>();
        buffer.sort_by_key(|entry| entry.size.main_axis);
        let mut remaining = remaining_size.main_axis;
        while let Some([smallest, rest @ ..]) = buffer.get_mut(..) {
            let second_smallest = rest
                .iter()
                .position(|entry| entry.size.main_axis != smallest.size.main_axis);
            match second_smallest {
                None => {
                    // distribute remaining space evenly
                    // +1 to include smallest element
                    let grow_count = rest.iter().filter(|entry| entry.is_grow).count() + 1;
                    if grow_count == 0 {
                        break;
                    }
                    let growth = remaining as usize / grow_count;
                    let growth = growth as u16;
                    let remainder = remaining as usize % grow_count;
                    let mut remainder = remainder as u16;
                    for entry in buffer.iter_mut() {
                        if !entry.is_grow {
                            continue;
                        }
                        match remainder {
                            0 => {
                                entry.size.main_axis += growth;
                            }
                            _ => {
                                entry.size.main_axis += growth + 1;
                                remainder -= 1;
                            }
                        }
                    }
                    break;
                }
                Some(second_smallest) => {
                    let end = second_smallest;
                    let target_size = rest[second_smallest].size.main_axis;
                    remaining = remaining
                        .saturating_sub(target_size.saturating_sub(smallest.size.main_axis));
                    for entry in buffer[..=end].iter_mut() {
                        if entry.is_grow {
                            entry.size.main_axis = target_size;
                        }
                    }
                }
            }
        }

        for entry in buffer {
            let mut query = self.query_one::<GrowQuery>(entry.entity)?;
            let query = query.get().unwrap();
            query.props.size = entry.size.to_u16vec2(direction);
        }

        for child in children.iter() {
            self.calculate_grow_sizes(child, false, area)?;
        }

        Ok(())
    }
    fn calculate_positions(&self, root: Element) -> Result<(), ComponentError> {
        let mut query = self.world.query_one::<(
            &Props,
            &Padding,
            &Children,
            &Direction,
            &Gap,
            &MainJustify,
            &CrossJustify,
        )>(root)?;
        let (&props, &padding, children, &dir, &gap, &main_justify, &cross_justify) =
            query.get().unwrap();
        let children = children.clone();
        drop(query);
        let space_used = self.sum_space_used(&children);
        let space_used = axify(space_used, dir).main_axis;
        let space_used = space_used + *gap * children.len().saturating_sub(1) as u16;
        let inner_size =
            props.size - u16vec2(padding.left + padding.right, padding.top + padding.bottom);
        let remaining_size = axify(props.size, dir)
            .shrink(padding, dir)
            .main_axis
            .saturating_sub(space_used);

        #[derive(Default)]
        struct AlignValues {
            start: u16,
            inbetween: u16,
            remainder: u16,
        }

        impl AlignValues {
            fn tick_rem(&mut self) -> u16 {
                match self.remainder {
                    0 => 0,
                    1.. => {
                        self.remainder -= 1;
                        1
                    }
                }
            }
        }

        let mut align = match main_justify {
            MainJustify::Start => AlignValues::default(),
            MainJustify::Center => AlignValues {
                start: remaining_size / 2,
                inbetween: 0,
                remainder: 0,
            },
            MainJustify::SpaceBetween if children.is_empty() => AlignValues::default(),
            MainJustify::SpaceBetween => {
                let div_by = (children.len().saturating_sub(1)) as u16;
                let space = remaining_size / div_by;
                let space_rem = remaining_size % div_by;
                AlignValues {
                    start: 0,
                    inbetween: space,
                    remainder: space_rem,
                }
            }
            MainJustify::SpaceAround if children.is_empty() => AlignValues::default(),
            MainJustify::SpaceAround => {
                let div_by = (children.len() * 2) as u16;
                let space = remaining_size / div_by;
                let space_rem = remaining_size % div_by;
                AlignValues {
                    start: space,
                    inbetween: space * 2,
                    remainder: space_rem,
                }
            }
            MainJustify::SpaceEvenly if children.is_empty() => AlignValues::default(),
            MainJustify::SpaceEvenly => {
                let div_by = (children.len() * 2) as u16 + 2;
                let space = remaining_size / div_by;
                AlignValues {
                    start: space * 2,
                    inbetween: space * 2,
                    remainder: 0,
                }
            }
            MainJustify::End => AlignValues {
                start: remaining_size,
                inbetween: 0,
                remainder: 0,
            },
        };

        children
            .iter()
            .try_for_each(|child| -> Result<(), ComponentError> {
                {
                    let mut child_props = self.world.get::<&mut Props>(child)?;
                    child_props.position = props.position;
                    match dir {
                        Direction::Horizontal => child_props.position.x += align.start,
                        Direction::Vertical => child_props.position.y += align.start,
                    }
                    child_props.position += u16vec2(padding.left, padding.top);
                    align.start = increase_axis(align.start, dir, child_props.size);
                    match (cross_justify, dir) {
                        (CrossJustify::Start, _) => {}
                        (CrossJustify::Center, Direction::Horizontal) => {
                            child_props.position.y +=
                                inner_size.y.saturating_sub(child_props.size.y).div(2);
                        }
                        (CrossJustify::Center, Direction::Vertical) => {
                            child_props.position.x +=
                                inner_size.x.saturating_sub(child_props.size.x).div(2);
                        }
                        (CrossJustify::End, Direction::Horizontal) => {
                            child_props.position.y +=
                                inner_size.y.saturating_sub(child_props.size.y);
                        }
                        (CrossJustify::End, Direction::Vertical) => {
                            child_props.position.x +=
                                inner_size.x.saturating_sub(child_props.size.x);
                        }
                    }
                    align.start += *gap + align.inbetween + align.tick_rem();
                }
                self.calculate_positions(child)?;
                Ok(())
            })?;

        Ok(())
    }
    /// runs the layout calculation step. takes the root element as the argument.
    ///
    /// # Error
    ///
    /// this will error if any element index is invalid. this can only happen if you manually despawn
    /// entities using [`hecs::World::despawn`] or other such methods.
    pub fn calculate_layout(&mut self, element: Element, area: Rect) -> Result<(), ComponentError> {
        self.calculate_fit_sizes(element)?;
        self.calculate_grow_sizes(element, true, area)?;
        self.calculate_positions(element)?;
        Ok(())
    }
    /// renders the tree.
    ///
    /// also see [`ratatui::prelude::Rect`], [`ratatui::prelude::Buffer`]
    pub fn render(&self, root: Element, area: Rect, buf: &mut Buffer) {
        let mut query = self
            .world
            .query_one::<(&mut Props, Option<&Children>)>(root)
            .expect("mana-tui-elemental bug: root element must have props");
        let (props, children) = query.get().unwrap();
        let area = props.split_area(area);
        (props.render)(self, root, area, buf);
        if let Some(children) = children {
            let children = children.clone();
            drop(query);
            for child in children.iter() {
                self.render(child, area, buf);
            }
        }
    }
}

fn increase_axis(init: u16, dir: Direction, size: U16Vec2) -> u16 {
    match dir {
        Direction::Horizontal => init + size.x,
        Direction::Vertical => init + size.y,
    }
}

#[derive(
    Debug, Clone, Copy, Default, d::Sub, d::SubAssign, d::Add, d::AddAssign, d::Sum, PartialEq, Eq,
)]
struct AxisSizes {
    main_axis: u16,
    cross_axis: u16,
}

const fn axify(vec: U16Vec2, dir: Direction) -> AxisSizes {
    AxisSizes::from_u16vec2(vec, dir)
}

impl AxisSizes {
    #[inline(always)]
    fn min(self, other: AxisSizes) -> AxisSizes {
        AxisSizes {
            main_axis: self.main_axis.min(other.main_axis),
            cross_axis: self.cross_axis.min(other.cross_axis),
        }
    }
    const fn with_main(mut self, value: u16) -> Self {
        self.main_axis = value;
        self
    }
    #[inline(always)]
    const fn from_u16vec2(value: U16Vec2, dir: Direction) -> Self {
        match dir {
            Direction::Horizontal => Self {
                main_axis: value.x,
                cross_axis: value.y,
            },
            Direction::Vertical => Self {
                main_axis: value.y,
                cross_axis: value.x,
            },
        }
    }
    #[inline(always)]
    const fn pad(self, padding: Padding, dir: Direction) -> AxisSizes {
        match dir {
            Direction::Horizontal => AxisSizes {
                main_axis: self.main_axis + padding.left + padding.right,
                cross_axis: self.cross_axis + padding.top + padding.bottom,
            },
            Direction::Vertical => AxisSizes {
                main_axis: self.main_axis + padding.top + padding.bottom,
                cross_axis: self.cross_axis + padding.left + padding.right,
            },
        }
    }
    #[inline(always)]
    const fn shrink(self, padding: Padding, dir: Direction) -> AxisSizes {
        match dir {
            Direction::Horizontal => AxisSizes {
                main_axis: self.main_axis.saturating_sub(padding.left + padding.right),
                cross_axis: self.cross_axis.saturating_sub(padding.top + padding.bottom),
            },
            Direction::Vertical => AxisSizes {
                main_axis: self.main_axis.saturating_sub(padding.top + padding.bottom),
                cross_axis: self.cross_axis.saturating_sub(padding.left + padding.right),
            },
        }
    }
    #[inline(always)]
    fn increase(self, by: U16Vec2, dir: Direction) -> AxisSizes {
        match dir {
            Direction::Horizontal => AxisSizes {
                main_axis: self.main_axis + by.x,
                cross_axis: self.cross_axis.max(by.y),
            },
            Direction::Vertical => AxisSizes {
                main_axis: self.main_axis + by.y,
                cross_axis: self.cross_axis.max(by.x),
            },
        }
    }
    #[inline(always)]
    const fn to_u16vec2(self, dir: Direction) -> U16Vec2 {
        match dir {
            Direction::Horizontal => u16vec2(self.main_axis, self.cross_axis),
            Direction::Vertical => u16vec2(self.cross_axis, self.main_axis),
        }
    }
}

/// type alias for [`hecs::Entity`]
pub type Element = Entity;

/// marker for any element created via [`ui`][crate::ui::ui]. you can use this query elements in the tree.
/// see [`hecs::World::query`] and [`hecs::World::query_mut`] for details.
pub struct TuiElMarker;

#[derive(Debug, Clone, Copy)]
pub(crate) struct Props {
    pub(crate) size: U16Vec2,
    pub(crate) position: U16Vec2,
    pub(crate) render: fn(&ElementCtx, Element, Rect, &mut Buffer),
}

impl Props {
    fn split_area(&self, area: Rect) -> Rect {
        area.intersection(Rect {
            // DONE: implement position
            x: self.position.x,
            y: self.position.y,
            width: self.size.x,
            height: self.size.y,
        })
    }
}

/// defines the [`Size`] on the x axis.
/// defaults to: `Size::Fit`
#[derive(Debug, Clone, Copy, Default, d::Deref)]
pub struct Width(pub Size);

/// defines the [`Size`] on the y axis.
/// defaults to: `Size::Fit`
#[derive(Debug, Clone, Copy, Default, d::Deref)]
pub struct Height(pub Size);

macro_rules! impl_sizing_functions {
    ($ty:ty) => {
        impl $ty {
            /// create a [`Size::Fixed`] value
            pub const fn fixed(value: u16) -> Self {
                Self(Size::Fixed(value))
            }
            /// create a [`Size::Fit`] value
            pub const fn fit() -> Self {
                Self(Size::Fit)
            }
            /// create a [`Size::Grow`] value
            pub const fn grow() -> Self {
                Self(Size::Grow)
            }
        }
    };
}

impl_sizing_functions!(Width);
impl_sizing_functions!(Height);

/// defines the gap on the main axis between child elements.
/// defaults to: 0`
///
/// # Example
///
/// Gap 2
/// ```plaintext
/// ╭parent──────────╮
/// │╭──╮  ╭──╮  ╭──╮│
/// ││  │  │  │  │  ││
/// │╰──╯  ╰──╯  ╰──╯│
/// ╰────────────────╯
/// ```
///
/// Gap 0
/// ```plaintext
/// ╭parent──────╮
/// │╭──╮╭──╮╭──╮│
/// ││  ││  ││  ││
/// │╰──╯╰──╯╰──╯│
/// ╰────────────╯
/// ```
#[derive(Debug, Clone, Copy, Default, d::Deref)]
pub struct Gap(pub u16);

/// holds a list of entity ids to the element's children. this component is added automatically.
/// you can use this to iterate the children of an element like this
///
/// ```rust
/// # use mana_tui_elemental::prelude::*;
/// # let mut ctx = ElementCtx::new();
/// # let root = ui(Block::new())
/// #     .with((Width(Size::Grow), Height(Size::Fixed(40))))
/// #     .children((
/// #         ui(Block::new()),
/// #         ui(Block::new())
/// #     ));
/// # let root = ctx.spawn_ui(root);
/// let children = ctx.get::<&Children>(root).unwrap();
/// for child in children.iter() {
///     let width = ctx.get::<&Width>(*child);
/// }
/// ```
#[derive(Debug, Clone, Default)]
pub enum Children {
    /// Thread-safe reference counted pointer to a vector of [`Element`]s
    Some(Arc<Vec<Element>>),
    /// no children. avoids Arc allocation
    #[default]
    None,
}

impl Children {
    fn iter<'a>(&'a self) -> ChildrenIter<'a> {
        self.into_iter()
    }
}

impl Deref for Children {
    type Target = [Element];

    fn deref(&self) -> &Self::Target {
        match self {
            Children::Some(items) => items.as_ref(),
            Children::None => &[],
        }
    }
}

/// Iterator over children IDs. this yields owned values since [`Elements`] is Copy.
pub struct ChildrenIter<'a> {
    inner: std::iter::Copied<std::slice::Iter<'a, Element>>,
}

impl<'a> Iterator for ChildrenIter<'a> {
    type Item = Element;

    fn next(&mut self) -> Option<Self::Item> {
        self.inner.next()
    }
}

impl<'a> IntoIterator for &'a Children {
    type Item = Element;

    type IntoIter = ChildrenIter<'a>;

    fn into_iter(self) -> Self::IntoIter {
        let inner = self.deref().iter().copied();
        ChildrenIter { inner }
    }
}

#[inline(always)]
fn cross_size(dir: Direction, x: Width, y: Height) -> Size {
    match dir {
        Direction::Horizontal => *y,
        Direction::Vertical => *x,
    }
}
#[inline(always)]
fn main_size(dir: Direction, x: Width, y: Height) -> Size {
    match dir {
        Direction::Horizontal => *x,
        Direction::Vertical => *y,
    }
}

/// defines the sizing strategy for an element.
#[derive(Default, Clone, Copy, Debug)]
pub enum Size {
    /// the element will be exactly `x` cells in size, clamped to it's parent's size.
    Fixed(u16),
    #[default]
    /// the element will grow to fit it's children, up to it's own parent's size
    Fit,
    /// the element will grow to fill it's parent, following a water-filling strategy, i.e. the smallest elements grow first.
    Grow,
}

/// defines the alignment strategy on the main axis.
#[derive(Default, Clone, Copy, Debug, strum::EnumIter)]
pub enum MainJustify {
    /// aligns the items toward the start of the container.
    ///
    /// ```plaintext
    /// ╭Start─────────────────╮
    /// │╭──╮╭──╮╭──╮          │
    /// ││#0││#1││#2│          │
    /// │╰──╯╰──╯╰──╯          │
    /// ╰──────────────────────╯
    /// ```
    #[default]
    Start,

    /// centers the items.
    ///
    /// ```plaintext
    /// ╭Center────────────────╮
    /// │     ╭──╮╭──╮╭──╮     │
    /// │     │#0││#1││#2│     │
    /// │     ╰──╯╰──╯╰──╯     │
    /// ╰──────────────────────╯
    /// ```
    Center,

    /// distributes the remaining space evenly between elements. inserts as much space between the elments as possible
    ///
    /// ```plaintext
    /// ╭SpaceBetween──────────╮
    /// │╭──╮     ╭──╮     ╭──╮│
    /// ││#0│     │#1│     │#2││
    /// │╰──╯     ╰──╯     ╰──╯│
    /// ╰──────────────────────╯
    /// ```
    SpaceBetween,

    /// distributes the remaining space evenly between elements such that there is an equal amount of space before
    /// and after each item.
    ///
    /// NOTE: this mode usually has poor results on small containers due to rounding issues.
    ///
    /// ```plaintext
    /// ╭SpaceAround───────────╮
    /// │ ╭──╮   ╭──╮   ╭──╮   │
    /// │ │#0│   │#1│   │#2│   │
    /// │ ╰──╯   ╰──╯   ╰──╯   │
    /// ╰──────────────────────╯
    /// ```
    SpaceAround,

    /// distributes the remaining space evenly between elements such that there is an equal amount of on each side of each item,
    /// accounting for the doubling of space that happens with [`Justify::SpaceAround`]
    ///
    /// NOTE: this mode usually has poor results on small containers due to rounding issues.
    ///
    /// ```plaintext
    /// ╭SpaceEvenly───────────╮
    /// │  ╭──╮  ╭──╮  ╭──╮    │
    /// │  │#0│  │#1│  │#2│    │
    /// │  ╰──╯  ╰──╯  ╰──╯    │
    /// ╰──────────────────────╯
    /// ```
    SpaceEvenly,

    /// aligns the items toward the end of the container.
    ///
    /// ```plaintext
    /// ╭End───────────────────╮
    /// │          ╭──╮╭──╮╭──╮│
    /// │          │#0││#1││#2││
    /// │          ╰──╯╰──╯╰──╯│
    /// ╰──────────────────────╯
    /// ```
    End,
}

#[derive(Default, Clone, Copy, Debug, strum::EnumIter)]
/// defines the alignment strategy on the cross axis.
pub enum CrossJustify {
    /// aligns the items toward the start of the container.
    #[default]
    Start,
    /// centers the items.
    Center,
    /// aligns the items toward the end of the container.
    End,
}

pub(crate) trait ManaComponent {
    fn run_postprocess(ctx: &mut ElementCtx, commands: &mut CommandBuffer);
}

/// equivalent to a `(MainJustify::Center, CrossJustify::Center)` bundle. this will make a container
/// center its children.
pub struct Center;

impl ManaComponent for Center {
    fn run_postprocess(ctx: &mut ElementCtx, _: &mut CommandBuffer) {
        // do not use the shared buffer
        let mut commands = CommandBuffer::new();
        for (node, _) in ctx.query_mut::<&Center>() {
            commands.insert_one(node, MainJustify::Center);
            commands.insert_one(node, CrossJustify::Center);
        }
        commands.run_on(ctx);
    }
}

impl Size {
    fn should_clamp(&self) -> bool {
        match self {
            Size::Fixed(_) => true,
            Size::Fit => false,
            Size::Grow => false,
        }
    }
    fn is_grow(&self) -> bool {
        matches!(self, Size::Grow)
    }
}
