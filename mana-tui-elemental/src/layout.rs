//! # Layout
//!
//! implements the layout algorithm.
use std::{ops::Deref, sync::Arc};

use derive_more as d;
use glam::{U16Vec2, u16vec2};
use hecs::{Component, ComponentError, Entity, Query, World};
use ratatui::{
    buffer::Buffer,
    layout::{Direction, Rect},
    widgets::{Padding, Widget},
};

/// trait for rendering elements through a shared reference. this is automatically implemented
/// for anything that implements [`Widget`], [`Clone`] and [`Component`]
pub trait ElWidget: std::fmt::Debug + Component {
    /// render the element through the shared reference. clones internally
    fn render_element(&self, area: Rect, buf: &mut Buffer);
}

impl<W: 'static> ElWidget for W
where
    W: Widget + Clone + std::fmt::Debug + Component,
{
    fn render_element(&self, area: Rect, buf: &mut Buffer) {
        self.clone().render(area, buf);
    }
}

/// Context struct that drives the layout engine.
///
/// # Usage
///
/// - [`ElementCtx::deref`] derefs to the inner [`hecs::World`]
/// - [`ElementCtx::spawn_ui`] takes a builder generated by the [`ui`][crate::ui::ui] function and spawns it and all its children
/// - [`ElementCtx::calculate_layout`] takes the root element and calculates sizes and positions.
/// - [`ElementCtx::render`] renders the tree to the provided buffer.
///
/// # Example
///
/// ```
/// # use mana_tui_elemental::prelude::*;
///
/// let mut ctx = ElementCtx::new();
/// let root = ctx.spawn_ui(root);
/// ctx.calculate_layout(root).unwrap();
/// // `&mut Buffer` from ratatui
/// ctx.render(root, buf.area, &mut buf);
/// ```
///
/// see [`ui module`][crate::ui] for more details.
#[derive(Default, d::Deref, d::DerefMut)]
pub struct ElementCtx {
    #[deref]
    #[deref_mut]
    pub(crate) world: World,
}

impl ElementCtx {
    /// create an empty context.
    pub fn new() -> Self {
        Self::default()
    }
    fn calculate_fit_sizes(&self, element: Element) -> Result<(), ComponentError> {
        let mut query = self
            .world
            .query_one::<(&Width, &Height, &Padding, &Children, &Direction)>(element)?;
        let (width, height, padding, children, direction) = query.get().unwrap();
        let mut props_query = self.world.query_one::<&mut Props>(element)?;
        let props = props_query.get().unwrap();

        if let Size::Fixed(size) = **width {
            props.size.x = size
        }
        if let Size::Fixed(size) = **height {
            props.size.y = size
        }
        let max_size = props.size.saturating_sub(u16vec2(
            padding.right + padding.left,
            padding.bottom + padding.top,
        ));

        let mut space_used = AxisSizes::default();

        drop(props_query);

        children
            .iter()
            .copied()
            .try_for_each(|child| -> Result<(), ComponentError> {
                self.calculate_fit_sizes(child)?;
                Ok(())
            })?;

        for child in children.iter().copied() {
            let mut child_props = self.world.get::<&mut Props>(child)?;
            if width.should_clamp() {
                child_props.size.x = child_props.size.x.clamp(0, max_size.x);
            }
            if height.should_clamp() {
                child_props.size.y = child_props.size.y.clamp(0, max_size.x);
            }
            space_used = space_used.increase(child_props.size, *direction);
        }

        let mut query = self.world.query_one::<(
            &mut Props,
            &Width,
            &Height,
            &Padding,
            &Children,
            &Direction,
            &Gap,
        )>(element)?;
        let (props, width, height, padding, children, direction, gap) = query.get().unwrap();

        space_used = space_used.pad(*padding, *direction);
        space_used.main_axis += children.len().saturating_sub(1) as u16 * **gap;
        let space_used = space_used.to_u16vec2(*direction);
        match **width {
            Size::Fit | Size::Grow => {
                props.size.x = space_used.x;
            }
            _ => {}
        }
        match **height {
            Size::Fit | Size::Grow => {
                props.size.y = space_used.y;
            }
            _ => {}
        }
        Ok(())
    }
    fn sum_space_used(&self, elements: &[Element]) -> U16Vec2 {
        elements
            .iter()
            .copied()
            .flat_map(|child| self.world.get::<&Props>(child))
            .map(|props| props.size)
            .sum::<U16Vec2>()
    }
    fn calculate_grow_sizes(&self, element: Element) -> Result<(), ComponentError> {
        let mut query = self
            .world
            .query_one::<(&mut Props, &Padding, &Children, &Direction, &Gap)>(element)?;
        let (props, &padding, children, &direction, &gap) = query.get().unwrap();
        let children = children.clone();
        let inner_size = props.size.saturating_sub(u16vec2(
            padding.right + padding.left,
            padding.bottom + padding.top,
        ));
        drop(query);
        let space_used = self.sum_space_used(&children);
        let remaining_size = inner_size.saturating_sub(space_used);
        let mut remaining_size = axify(remaining_size, direction);
        remaining_size.main_axis = remaining_size
            .main_axis
            .saturating_sub(children.len().saturating_sub(1) as u16 * *gap);

        // cross axis
        children
            .iter()
            .copied()
            .try_for_each(|child| -> Result<(), ComponentError> {
                let mut child_query = self
                    .world
                    .query_one::<(&mut Props, &Width, &Height)>(child)?;
                let (child_props, child_width, child_height) = child_query.get().unwrap();
                if !cross_size(direction, *child_width, *child_height).is_grow() {
                    return Ok(());
                }
                let mut size = AxisSizes::from_u16vec2(child_props.size, direction);
                size.cross_axis = axify(inner_size, direction).cross_axis;
                child_props.size = size.to_u16vec2(direction);
                Ok(())
            })?;

        // main axis
        #[derive(Query, Debug)]
        struct GrowQuery<'a> {
            props: &'a mut Props,
            width: &'a Width,
            height: &'a Height,
        }
        #[derive(d::Debug)]
        struct GrowEntry {
            is_grow: bool,
            #[debug("({}, {})", self.size.main_axis, self.size.cross_axis)]
            size: AxisSizes,
            entity: Element,
        }
        let mut buffer = children
            .iter()
            .copied()
            .flat_map(|child| self.query_one::<GrowQuery>(child).ok().zip(Some(child)))
            .map(|(mut grow_query, entity)| {
                let grow_query = grow_query.get().unwrap();
                let is_grow = main_size(direction, *grow_query.width, *grow_query.height).is_grow();
                let size = axify(grow_query.props.size, direction);
                GrowEntry {
                    is_grow,
                    size,
                    entity,
                }
            })
            .collect::<Vec<_>>();
        buffer.sort_by_key(|entry| entry.size.main_axis);
        let mut remaining = remaining_size.main_axis;
        while let Some([smallest, rest @ ..]) = buffer.get_mut(..) {
            let second_smallest = rest
                .iter()
                .position(|entry| entry.size.main_axis != smallest.size.main_axis);
            match second_smallest {
                None => {
                    // distribute remaining space evenly
                    // +1 to include smallest element
                    let grow_count = rest.iter().filter(|entry| entry.is_grow).count() + 1;
                    if grow_count == 0 {
                        break;
                    }
                    let growth = remaining as usize / grow_count;
                    let growth = growth as u16;
                    let remainder = remaining as usize % grow_count;
                    let mut remainder = remainder as u16;
                    for entry in buffer.iter_mut() {
                        if !entry.is_grow {
                            continue;
                        }
                        match remainder {
                            0 => {
                                entry.size.main_axis += growth;
                            }
                            _ => {
                                entry.size.main_axis += growth + 1;
                                remainder -= 1;
                            }
                        }
                    }
                    break;
                }
                Some(second_smallest) => {
                    let end = second_smallest;
                    let target_size = rest[second_smallest].size.main_axis;
                    remaining = remaining
                        .saturating_sub(target_size.saturating_sub(smallest.size.main_axis));
                    for entry in buffer[..=end].iter_mut() {
                        if entry.is_grow {
                            entry.size.main_axis = target_size;
                        }
                    }
                }
            }
        }

        for entry in buffer {
            let mut query = self.query_one::<GrowQuery>(entry.entity)?;
            let query = query.get().unwrap();
            query.props.size = entry.size.to_u16vec2(direction);
        }

        for child in children.iter().copied() {
            self.calculate_grow_sizes(child)?;
        }

        Ok(())
    }
    fn calculate_positions(&self, root: Element) -> Result<(), ComponentError> {
        let mut query = self
            .world
            .query_one::<(&Props, &Padding, &Children, &Direction, &Gap, &MainJustify)>(root)?;
        let (&props, &padding, children, &dir, &gap, &main_justify) = query.get().unwrap();
        let children = children.clone();
        drop(query);
        let space_used = self.sum_space_used(&children);
        let space_used = axify(space_used, dir).main_axis;
        let space_used = space_used + *gap * children.len().saturating_sub(1) as u16;
        let remaining_size = axify(props.size, dir)
            .shrink(padding, dir)
            .main_axis
            .saturating_sub(space_used);

        #[derive(Default)]
        struct AlignValues {
            start: u16,
            inbetween: u16,
            remainder: u16,
        }

        impl AlignValues {
            fn tick_rem(&mut self) -> u16 {
                match self.remainder {
                    0 => 0,
                    1.. => {
                        self.remainder -= 1;
                        1
                    }
                }
            }
        }

        let mut align = match *main_justify {
            Justify::Start => AlignValues::default(),
            Justify::Center => AlignValues {
                start: remaining_size / 2,
                inbetween: 0,
                remainder: 0,
            },
            Justify::SpaceBetween if children.is_empty() => AlignValues::default(),
            Justify::SpaceBetween => {
                let div_by = (children.len().saturating_sub(1)) as u16;
                let space = remaining_size / div_by;
                let space_rem = remaining_size % div_by;
                AlignValues {
                    start: 0,
                    inbetween: space,
                    remainder: space_rem,
                }
            }
            Justify::SpaceAround if children.is_empty() => AlignValues::default(),
            Justify::SpaceAround => {
                let div_by = (children.len() * 2) as u16;
                let space = remaining_size / div_by;
                let space_rem = remaining_size % div_by;
                AlignValues {
                    start: space,
                    inbetween: space * 2,
                    remainder: space_rem,
                }
            }
            Justify::SpaceEvenly if children.is_empty() => AlignValues::default(),
            Justify::SpaceEvenly => {
                let div_by = (children.len() * 2) as u16 + 2;
                let space = remaining_size / div_by;
                AlignValues {
                    start: space * 2,
                    inbetween: space * 2,
                    remainder: 0,
                }
            }
            Justify::End => AlignValues {
                start: remaining_size,
                inbetween: 0,
                remainder: 0,
            },
        };

        children
            .iter()
            .copied()
            .try_for_each(|child| -> Result<(), ComponentError> {
                {
                    let mut child_props = self.world.get::<&mut Props>(child)?;
                    child_props.position = props.position;
                    match dir {
                        Direction::Horizontal => child_props.position.x += align.start,
                        Direction::Vertical => child_props.position.y += align.start,
                    }
                    child_props.position += u16vec2(padding.left, padding.top);
                    align.start = increase_axis(align.start, dir, child_props.size);
                    align.start += *gap + align.inbetween + align.tick_rem();
                }
                self.calculate_positions(child)?;
                Ok(())
            })?;

        Ok(())
    }
    /// runs the layout calculation step. takes the root element as the argument.
    ///
    /// # Error
    ///
    /// this will error if any element index is invalid. this can only happen if you manually despawn
    /// entities using [`hecs::World::despawn`] or other such methods.
    pub fn calculate_layout(&mut self, element: Element) -> Result<(), ComponentError> {
        self.calculate_fit_sizes(element)?;
        self.calculate_grow_sizes(element)?;
        self.calculate_positions(element)?;
        Ok(())
    }
    /// renders the tree.
    ///
    /// also see [`ratatui::prelude::Rect`], [`ratatui::prelude::Buffer`]
    pub fn render(&self, root: Element, area: Rect, buf: &mut Buffer) {
        let mut query = self
            .world
            .query_one::<(&mut Props, Option<&Children>)>(root)
            .expect("mana-tui-elemental bug: root element must have props");
        let (props, children) = query.get().unwrap();
        let area = props.split_area(area);
        (props.render)(self, root, area, buf);
        if let Some(children) = children {
            let children = children.clone();
            drop(query);
            for child in children.iter().copied() {
                self.render(child, area, buf);
            }
        }
    }
}

fn increase_axis(init: u16, dir: Direction, size: U16Vec2) -> u16 {
    match dir {
        Direction::Horizontal => init + size.x,
        Direction::Vertical => init + size.y,
    }
}

#[derive(
    Debug, Clone, Copy, Default, d::Sub, d::SubAssign, d::Add, d::AddAssign, d::Sum, PartialEq, Eq,
)]
struct AxisSizes {
    main_axis: u16,
    cross_axis: u16,
}

const fn axify(vec: U16Vec2, dir: Direction) -> AxisSizes {
    AxisSizes::from_u16vec2(vec, dir)
}

impl AxisSizes {
    #[inline(always)]
    fn min(self, other: AxisSizes) -> AxisSizes {
        AxisSizes {
            main_axis: self.main_axis.min(other.main_axis),
            cross_axis: self.cross_axis.min(other.cross_axis),
        }
    }
    const fn with_main(mut self, value: u16) -> Self {
        self.main_axis = value;
        self
    }
    #[inline(always)]
    const fn from_u16vec2(value: U16Vec2, dir: Direction) -> Self {
        match dir {
            Direction::Horizontal => Self {
                main_axis: value.x,
                cross_axis: value.y,
            },
            Direction::Vertical => Self {
                main_axis: value.y,
                cross_axis: value.x,
            },
        }
    }
    #[inline(always)]
    const fn pad(self, padding: Padding, dir: Direction) -> AxisSizes {
        match dir {
            Direction::Horizontal => AxisSizes {
                main_axis: self.main_axis + padding.left + padding.right,
                cross_axis: self.cross_axis + padding.top + padding.bottom,
            },
            Direction::Vertical => AxisSizes {
                main_axis: self.main_axis + padding.top + padding.bottom,
                cross_axis: self.cross_axis + padding.left + padding.right,
            },
        }
    }
    #[inline(always)]
    const fn shrink(self, padding: Padding, dir: Direction) -> AxisSizes {
        match dir {
            Direction::Horizontal => AxisSizes {
                main_axis: self.main_axis.saturating_sub(padding.left + padding.right),
                cross_axis: self.cross_axis.saturating_sub(padding.top + padding.bottom),
            },
            Direction::Vertical => AxisSizes {
                main_axis: self.main_axis.saturating_sub(padding.top + padding.bottom),
                cross_axis: self.cross_axis.saturating_sub(padding.left + padding.right),
            },
        }
    }
    #[inline(always)]
    fn increase(self, by: U16Vec2, dir: Direction) -> AxisSizes {
        match dir {
            Direction::Horizontal => AxisSizes {
                main_axis: self.main_axis + by.x,
                cross_axis: self.cross_axis.max(by.y),
            },
            Direction::Vertical => AxisSizes {
                main_axis: self.main_axis + by.y,
                cross_axis: self.cross_axis.max(by.x),
            },
        }
    }
    #[inline(always)]
    const fn to_u16vec2(self, dir: Direction) -> U16Vec2 {
        match dir {
            Direction::Horizontal => u16vec2(self.main_axis, self.cross_axis),
            Direction::Vertical => u16vec2(self.cross_axis, self.main_axis),
        }
    }
}

/// type alias for [`hecs::Entity`]
pub type Element = Entity;

/// marker for any element created via [`ui`][crate::ui::ui]. you can use this query elements in the tree.
/// see [`hecs::World::query`] and [`hecs::World::query_mut`] for details.
pub struct TuiElMarker;

#[derive(Debug, Clone, Copy)]
pub(crate) struct Props {
    pub(crate) size: U16Vec2,
    pub(crate) position: U16Vec2,
    pub(crate) render: fn(&ElementCtx, Element, Rect, &mut Buffer),
}

impl Props {
    fn split_area(&self, area: Rect) -> Rect {
        area.intersection(Rect {
            // DONE: implement position
            x: self.position.x,
            y: self.position.y,
            width: self.size.x,
            height: self.size.y,
        })
    }
}

/// defines the [`Size`] on the x axis.
/// defaults to: `Size::Fit`
#[derive(Debug, Clone, Copy, Default, d::Deref)]
pub struct Width(pub Size);
/// defines the [`Size`] on the y axis.
/// defaults to: `Size::Fit`
#[derive(Debug, Clone, Copy, Default, d::Deref)]
pub struct Height(pub Size);
/// defines the gap on the main axis between child elements.
/// defaults to: 0`
///
/// # Example
///
/// Gap 2
/// ```plaintext
/// ╭parent──────────╮
/// │╭──╮  ╭──╮  ╭──╮│
/// ││  │  │  │  │  ││
/// │╰──╯  ╰──╯  ╰──╯│
/// ╰────────────────╯
/// ```
///
/// Gap 0
/// ```plaintext
/// ╭parent──────╮
/// │╭──╮╭──╮╭──╮│
/// ││  ││  ││  ││
/// │╰──╯╰──╯╰──╯│
/// ╰────────────╯
/// ```
#[derive(Debug, Clone, Copy, Default, d::Deref)]
pub struct Gap(pub u16);
#[derive(Debug, Clone, Copy, Default, d::Deref)]
/// defines the alignment on the main axis. see [`Justify`] for more details.
/// defaults to: [`Justify::Start`]
pub struct MainJustify(pub Justify);
/// holds a list of entity ids to the element's children. this component is added automatically.
/// you can use this to iterate the children of an element like this
///
/// ```rust
/// # let mut ctx = ElementCtx::new();
/// # let root = ui(Block::new())
/// #     .with((Width(Size::Grow), Height(Size::Fixed(40))))
/// #     .children((
/// #         ui(Block::new()),
/// #         ui(Block::new())
/// #     ));
/// # let root = ctx.spawn_ui(root);
/// let children = ctx.get::<&Chidlren>(root).unwrap();
/// for child in children {
///     let width = ctx.get::<&Width>(child);
/// }
/// ```
#[derive(Debug, Clone, Default)]
pub enum Children {
    /// Thread-safe reference counted pointer to a vector of [`Element`]s
    Some(Arc<Vec<Element>>),
    /// no children. avoids Arc allocation
    #[default]
    None,
}

impl Deref for Children {
    type Target = [Element];

    fn deref(&self) -> &Self::Target {
        match self {
            Children::Some(items) => items.as_ref(),
            Children::None => &[],
        }
    }
}

#[inline(always)]
fn cross_size(dir: Direction, x: Width, y: Height) -> Size {
    match dir {
        Direction::Horizontal => *y,
        Direction::Vertical => *x,
    }
}
#[inline(always)]
fn main_size(dir: Direction, x: Width, y: Height) -> Size {
    match dir {
        Direction::Horizontal => *x,
        Direction::Vertical => *y,
    }
}

/// defines the sizing strategy for an element.
#[derive(Default, Clone, Copy, Debug)]
pub enum Size {
    /// the element will be exactly `x` cells in size, clamped to it's parent's size.
    Fixed(u16),
    #[default]
    /// the element will grow to fit it's children, up to it's own parent's size
    Fit,
    /// the element will grow to fill it's parent, following a water-filling strategy, i.e. the smallest elements grow first.
    Grow,
}

/// defines the alignment strategy.
#[derive(Default, Clone, Copy, Debug)]
pub enum Justify {
    /// aligns the items toward the start of the container.
    ///
    /// ## Main axis
    ///
    /// ╭Start─────────────────╮
    /// │╭──╮╭──╮╭──╮          │
    /// ││#0││#1││#2│          │
    /// │╰──╯╰──╯╰──╯          │
    /// ╰──────────────────────╯
    #[default]
    Start,

    /// centers the items.
    ///
    /// ## Main axis
    ///
    /// ╭Center────────────────╮
    /// │     ╭──╮╭──╮╭──╮     │
    /// │     │#0││#1││#2│     │
    /// │     ╰──╯╰──╯╰──╯     │
    /// ╰──────────────────────╯
    Center,

    /// distributes the remaining space evenly between elements. inserts as much space between the elments as possible
    ///
    /// # Main axis
    ///
    /// ╭SpaceBetween──────────╮
    /// │╭──╮     ╭──╮     ╭──╮│
    /// ││#0│     │#1│     │#2││
    /// │╰──╯     ╰──╯     ╰──╯│
    /// ╰──────────────────────╯
    SpaceBetween,

    /// distributes the remaining space evenly between elements such that there is an equal amount of space before
    /// and after each item.
    ///
    /// NOTE: this mode usually has poor results on small containers due to rounding issues.
    ///
    /// # Main axis
    ///
    /// ╭SpaceAround───────────╮
    /// │ ╭──╮   ╭──╮   ╭──╮   │
    /// │ │#0│   │#1│   │#2│   │
    /// │ ╰──╯   ╰──╯   ╰──╯   │
    /// ╰──────────────────────╯
    SpaceAround,

    /// distributes the remaining space evenly between elements such that there is an equal amount of on each side of each item,
    /// accounting for the doubling of space that happens with [`Justify::SpaceAround`]
    ///
    /// NOTE: this mode usually has poor results on small containers due to rounding issues.
    ///
    /// # Main axis
    ///
    /// ╭SpaceEvenly───────────╮
    /// │  ╭──╮  ╭──╮  ╭──╮    │
    /// │  │#0│  │#1│  │#2│    │
    /// │  ╰──╯  ╰──╯  ╰──╯    │
    /// ╰──────────────────────╯
    SpaceEvenly,

    /// aligns the items toward the end of the container.
    ///
    /// ## Main axis
    ///
    /// ╭End───────────────────╮
    /// │          ╭──╮╭──╮╭──╮│
    /// │          │#0││#1││#2││
    /// │          ╰──╯╰──╯╰──╯│
    /// ╰──────────────────────╯
    End,
}

impl Justify {
    /// iterates over every variant of justify.
    pub fn iter() -> impl Iterator<Item = Justify> {
        [
            Self::Start,
            Self::Center,
            Self::SpaceBetween,
            Self::SpaceAround,
            Self::SpaceEvenly,
            Self::End,
        ]
        .into_iter()
    }
}

impl Size {
    fn should_clamp(&self) -> bool {
        match self {
            Size::Fixed(_) => true,
            Size::Fit => false,
            Size::Grow => false,
        }
    }
    fn is_grow(&self) -> bool {
        matches!(self, Size::Grow)
    }
}
